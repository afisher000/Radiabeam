function h.fig=crossprofile(h,I)
% Updated 2020-July-20 by M.Ruelas
% Tested in Matlab R2012a after porting from python/matlab mashup.
% **This function may require image processing toolbox.
% ***crossprofile() can be used to find the vertical and horizontal FWHM
% of a peak in a .tiff image file.
% After selecting an image, crossprofile() will display the image, find the
% centroid, then find the FWHM from a baseline defined below. The baseline 
% can be edited in the GUI. The data analysis can be saved as a bitmap, 
% .png, and .pdf file.
% **Some reporting to terminal (command window). If no centroid is found,
% then the user should push the 'Profile' button to manually select a peak.
% Minimal error handling.
% It is recommended to close other figures generated by crossprofile() to
% prevent errors with callback and handle assignment.
% Update on Jul 20 now reports the brightness as twice the half max height
% above baseline.

% ---DEFAULT PARAMETERS---%
% default_baseline=25;        %The default pizel level to use for FWHM baseline
% film_length_shorter=8*2.54; %The length of the shorter side of the film in units of cm
sat_level=floor(0.97*256);  %the saturation level for display purposed, scaled to 256 bits       


% ---BEGIN MAIN FUNCTION ATTRIBUTES

% Begin function by reading in data
       
    h.fig=figure('Units','normalized',...
                'Tag','CrossProfile');

%---Build up gui interaction---%
% create panel for buttons
panel_left=.65;
    h.panel=uipanel(h.fig,'Units','Normalized',...
        'Position',[panel_left,.05,0.92-panel_left,.2]);


%Create label for reporting prof.x.fwhm
    h.xlabel=uicontrol(h.panel,'Style','Text',...
        'Units','Normalized',...
        'Position',[0,0.2,.5,.2],...
        'HorizontalAlignment','right',...
        'String','FWHM_x [cm]=');
    
%Create outbox for reporting prof.x.fwhm
    h.xfwhm=uicontrol(h.panel,'Style','Text',...
        'Units','Normalized',...
        'Position',[0.5,0.2,.5,.2],...
        'String','?');
    
%Create box for reporting prof.y.fwhm
    h.ylabel=uicontrol(h.panel,'Style','Text',...
        'Units','Normalized',...
        'Position',[0,0.4,.5,.2],...
        'HorizontalAlignment','right',...
        'String','FWHM_y [cm]=');
%Create outbox for reporting prof.y.fwhm
    h.yfwhm=uicontrol(h.panel,'Style','Text',...
        'Units','Normalized',...
        'Position',[0.5,0.4,.5,.2],...
        'String','?');
    
%Create box for reporting peak
    h.peak=uicontrol(h.panel,'Style','Text',...
        'Units','Normalized',...
        'Position',[0,0.6,.5,.2],...
        'HorizontalAlignment','right',...
        'String','Brightness[-]=');
%Create box for reporting baseline
    h.peak=uicontrol(h.panel,'Style','Text',...
        'Units','Normalized',...
        'Position',[.5,0.6,.5,.2],...
        'String',num2str(0),...
        'TooltipString','Peak height above baseline');   
    
%Create box for reporting baseline
    h.baselinelabel=uicontrol(h.panel,'Style','Text',...
        'Units','Normalized',...
        'Position',[0,0.8,.5,.2],...
        'HorizontalAlignment','right',...
        'String','Baseline=');
%Create box for reporting baseline
    h.baseline=uicontrol(h.panel,'Style','edit',...
        'Units','Normalized',...
        'Position',[.5,0.8,.5,.2],...
        'String',num2str(default_baseline),...
        'TooltipString','Level, in brightness, to use for baseline of FWHM');            
            
% plot image
    h.aima=subplot(4,3,[1 2 4 5 7 8]);
    cmap=vertcat(jet(sat_level), (cool(256-sat_level)));
    h.image=imshow(I,'Parent',h.aima,'Colormap',jet); hold on;
    title(h.titStr,'Interpreter','none');
    set(h.fig,'Colormap',cmap)
    colorbar('location', 'WestOutside')
    set(h.aima,'xticklabel',[])
    set(h.aima,'yticklabel',[])


    
    
% Calculate calibration pixel size
    h.pixel_cal=(film_length_shorter)/min(size(I));
    
    h.xplot=subplot(4,3,[10 11]);    % bottom plot
    set(h.xplot,'Tag','x_profile')

    h.yplot=subplot(4,3,[3 6 9]);    % right plot
    set(h.yplot,'Tag','y_profile')
    set(h.yplot,'Ydir','reverse')
    set(h.yplot,'YAxisLocation','right')

% Attempt to find centroid automatically
    [x0,y0,ctrtype]=autoCentroid(h,I);
    if strcmp(ctrtype,'automatic')
        h.centroid=plot(h.aima,x0,y0,'go');           % plot autoCentroid results
        update_profile(h,I,x0,y0);
    end

    set(h.fig,'HandleVisibility','callback');
    
% %Create test box for reporting
%     h.report=uicontrol(h.panel,'Style','Text',...
%         'Units','Normalized',...
%         'Position',[0.55,0.2,0.45,0.8],...
%         'String',h.titStr);    
    
    
% Create button for manual point selection
    h.pb_manprof=uicontrol(h.panel,'Style','pushbutton',...
        'String','Profile',...
        'Units','Normalized',...
        'Position',[0,0,0.5,.2],...
        'Callback',{@manual_profile,h});

% Create button for calculating FWHM
%     h.pb_calcFWHM=uicontrol(h.panel,'Style','pushbutton',...
%         'String','Calculate FWHM',...
%         'Units','Normalized',...
%         'Position',[.34,0,0.32,.15],...
%         'Callback',{@calcFWHM,h});

%Create button to save all data
    h.pb_save=uicontrol(h.panel,'Style','pushbutton',...
        'String','Save Data',...
        'Units','Normalized',...
        'Position',[1-0.5,0,0.5,.2],...
        'Callback',{@saveData,h});
        
    
end

% Get profile information
function prof = update_profile(h,I,x0,y0)
% called to update profiles
    [ny nx]=size(I);
    
% Get FWHM baseline for subsequent use
    baseline=floor(str2double(get(h.baseline,'String')));   % read the baseline from user input and floor it
    set(h.baseline,'String',num2str(baseline))              % display the floored baseline to gui
    
%---This is a convulted way to align positions when using imshow()
%--- Find the image position, then scale, so that the profile plots can be
% aligned with the image edges

    haxis=h.aima;
    posvi=get(haxis,'position');
    currunit = get(haxis, 'units');     % get unit type of current axis with handle haxis
    axisPos  = getpixelposition(haxis); % get the pixel position of the axis w/handle h

    % get the axis span and increment size
    xlim = get(haxis, 'XLim');
    ylim = get(haxis, 'YLim');
    dx = diff(xlim);
    dy = diff(ylim);


    dar = get(haxis, 'DataAspectRatio');
    pbar = get(haxis, 'PlotBoxAspectRatio');

    limDarRatio = (dx/dar(1))/(dy/dar(2));
    pbarRatio = pbar(1)/pbar(2);

    axisRatio = axisPos(3)/axisPos(4);
    if limDarRatio > axisRatio
        pos(1) = axisPos(1);
        pos(3) = axisPos(3);
        pos(4) = axisPos(3)/limDarRatio;
        pos(2) = (axisPos(4) - pos(4))/2 + axisPos(2);
    else
        pos(2) = axisPos(2);
        pos(4) = axisPos(4);
        pos(3) = axisPos(4) * limDarRatio;
        pos(1) = (axisPos(3) - pos(3))/2 + axisPos(1);
    end

    h.parent = get(haxis, 'parent');
    h.p2 = ancestor(h.parent, 'figure'); % in case in panel or similar
    currax = get(h.p2, 'currentaxes');


    temp = axes('Units', 'Pixels', 'Position', pos, 'Visible', 'off', 'parent', h.parent);
    set(temp, 'Units', currunit);
    pos = get(temp, 'position');
    delete(temp)
    set(h.fig, 'currentaxes', currax);  
    
    
% First get the profile using improfile(), then update the plot. We will
% also massage the position of the subplot to match the position of the
% image that is stored in the h function. Most information is in the
% handles stored in h. The handle made by subplot is in h.xplot
    
    
    [prof.x.d ~ prof.x.p]=improfile(I,[1,nx],[y0,y0]);    %profile along x
    plot(h.xplot,[0 nx],baseline*[1 1],':g')
    axes(h.xplot); hold on
    plot(h.xplot,prof.x.d,prof.x.p,'r')
    axis(h.xplot,[0,nx,0,300]);
    posv=get(h.xplot,'Position');
    set(h.xplot,'Position',[pos(1) posv(2) pos(3) posv(4)])
%     plot(h.xplot,
    grid on
    hold off

    
    [~, prof.y.d prof.y.p]=improfile(I,[x0,x0],[1,ny]);    %profile along y
    plot(h.yplot,baseline*[1 1],[0 ny],':g')
    axes(h.yplot); hold on
    plot(h.yplot,prof.y.p,prof.y.d,'r')
    set(h.yplot,'Ydir','reverse')
    axis(h.yplot,[0,300,0,ny]); 
    posv=get(h.yplot,'Position');
    set(h.yplot,'Position',[posv(1) pos(2) posv(3) pos(4)])
    grid on
    hold off

% call function to calculate FWHM
    prof.x.fwhm = calcFWHM(prof.x.d,prof.x.p,baseline);
    prof.y.fwhm = calcFWHM(prof.y.d,prof.y.p,baseline);
    set(h.peak,'String',num2str(2*prof.x.fwhm.halflevel-baseline))


%Update gui display with FWHM. Note the pixel calibration is used
    set(h.xfwhm,'String',num2str(prof.x.fwhm.width*h.pixel_cal,'%.2f'))
    axes(h.xplot); hold on;
    fill([prof.x.fwhm.d1, prof.x.fwhm.d2, prof.x.fwhm.d2, prof.x.fwhm.d1],...
        [baseline, baseline, prof.x.fwhm.halflevel, prof.x.fwhm.halflevel],'b')
    hold off
    
    axes(h.yplot); hold on;
    fill([baseline, baseline, prof.x.fwhm.halflevel, prof.x.fwhm.halflevel],...
        [prof.y.fwhm.d1, prof.y.fwhm.d2, prof.y.fwhm.d2, prof.y.fwhm.d1],'b')
    hold off
    set(h.yfwhm,'String',num2str(prof.y.fwhm.width*h.pixel_cal,'%.2f'))

end

function manual_profile(hObj,event,h)
    [x0,y0]=ginput(1);
    I=get(h.image,'CData');
    update_profile(h,I,round(x0),round(y0));
%     set(h.centroid,'XData'

end

function fwhm=calcFWHM(d,response,baseline)

% brute force half level. Prefer to smooth first...
    fwhm.halflevel=(baseline + max(response)) /2;

% get the left-most index corresponding to a point above the half level
    idd1=find(response>fwhm.halflevel,1) + [-1 0];
% get the right-most index corresponding to a point above the half level
    idd2=find(response>fwhm.halflevel,1,'last') +[0 1];

    if max(idd2>length(response)) || min(idd1<1)
        disp('FWHM exceed image dimensions for this baseline')
        fwhm.d1=0;
        fwhm.d2=0;
        fwhm.width=0;
        return
    end
    center=(idd1+idd2)/2;
    
    fwhm.d1 = interp1(response(idd1),d(idd1),fwhm.halflevel);
    fwhm.d2 = interp1(response(idd2),d(idd2),fwhm.halflevel);
    fwhm.width = fwhm.d2 - fwhm.d1;
end

function saveData(hObj,event,h)

    saveas(h.fig,h.titStr,'pdf')
    saveas(h.fig,h.titStr,'fig')
    saveas(h.fig,h.titStr,'png')
% we should also save the line-out data
end

